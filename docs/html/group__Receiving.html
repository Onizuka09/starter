<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Starter: Receiving IR data for multiple protocols</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Starter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Receiving IR data for multiple protocols</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6a18c840bbf00da32a4e35a85342095a"><td class="memItemLeft" align="right" valign="top"><a id="ga6a18c840bbf00da32a4e35a85342095a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga6a18c840bbf00da32a4e35a85342095a">FNV_PRIME_32</a>&#160;&#160;&#160;16777619</td></tr>
<tr class="memdesc:ga6a18c840bbf00da32a4e35a85342095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for decodeHash() <br /></td></tr>
<tr class="separator:ga6a18c840bbf00da32a4e35a85342095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346d5186e56ca2ce520d59681479c808"><td class="memItemLeft" align="right" valign="top"><a id="ga346d5186e56ca2ce520d59681479c808"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga346d5186e56ca2ce520d59681479c808">FNV_BASIS_32</a>&#160;&#160;&#160;2166136261</td></tr>
<tr class="memdesc:ga346d5186e56ca2ce520d59681479c808"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for decodeHash() <br /></td></tr>
<tr class="separator:ga346d5186e56ca2ce520d59681479c808"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab93c1433c1d6ab5e5bcdcb37339b2fb7"><td class="memItemLeft" align="right" valign="top"><a id="gab93c1433c1d6ab5e5bcdcb37339b2fb7"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getProtocolString</b> (<a class="el" href="IRProtocol_8h.html#ad5b287a488a8c1b7b8661f029ab56fad">decode_type_t</a> aProtocol)</td></tr>
<tr class="separator:gab93c1433c1d6ab5e5bcdcb37339b2fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac45e8ead5e96868e61c65cd354758d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gac45e8ead5e96868e61c65cd354758d4d">printIRResultShort</a> (<a class="el" href="classPrint.html">Print</a> *aSerial, <a class="el" href="structIRData.html">IRData</a> *aIRDataPtr, bool aPrintRepeatGap)</td></tr>
<tr class="separator:gac45e8ead5e96868e61c65cd354758d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e4a5acb86af8c967f8cae7e75062cb"><td class="memItemLeft" align="right" valign="top"><a id="ga95e4a5acb86af8c967f8cae7e75062cb"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>bitreverseOneByte</b> (uint8_t aValue)</td></tr>
<tr class="separator:ga95e4a5acb86af8c967f8cae7e75062cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7c345c1b554ca8f3069b5fb767f07d6"><td class="memItemLeft" align="right" valign="top"><a id="gad7c345c1b554ca8f3069b5fb767f07d6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>bitreverse32Bit</b> (uint32_t aInput)</td></tr>
<tr class="separator:gad7c345c1b554ca8f3069b5fb767f07d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770e03720a79491d7ddf347ad4b9e484"><td class="memItemLeft" align="right" valign="top"><a id="ga770e03720a79491d7ddf347ad4b9e484"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRReceiveTimerInterruptHandler</b> ()</td></tr>
<tr class="separator:ga770e03720a79491d7ddf347ad4b9e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495b7f49ff71cde1289b118fac0f0674"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga495b7f49ff71cde1289b118fac0f0674">matchTicks</a> (uint16_t aMeasuredTicks, uint16_t aMatchValueMicros)</td></tr>
<tr class="separator:ga495b7f49ff71cde1289b118fac0f0674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9263ab71af2d2895add92f72a05ee9"><td class="memItemLeft" align="right" valign="top"><a id="ga0f9263ab71af2d2895add92f72a05ee9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MATCH</b> (uint16_t measured_ticks, uint16_t desired_us)</td></tr>
<tr class="separator:ga0f9263ab71af2d2895add92f72a05ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4472564ea96b1ee10b51f594f60d7aeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga4472564ea96b1ee10b51f594f60d7aeb">matchMark</a> (uint16_t aMeasuredTicks, uint16_t aMatchValueMicros)</td></tr>
<tr class="separator:ga4472564ea96b1ee10b51f594f60d7aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab293a71386f20571db6d779d1d84b7"><td class="memItemLeft" align="right" valign="top"><a id="gadab293a71386f20571db6d779d1d84b7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MATCH_MARK</b> (uint16_t measured_ticks, uint16_t desired_us)</td></tr>
<tr class="separator:gadab293a71386f20571db6d779d1d84b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7902b620f6c01463b5b6e50ef604ac8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga7902b620f6c01463b5b6e50ef604ac8b">matchSpace</a> (uint16_t aMeasuredTicks, uint16_t aMatchValueMicros)</td></tr>
<tr class="separator:ga7902b620f6c01463b5b6e50ef604ac8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91e763e3ae44501f7c4f7b7ff8aca0f"><td class="memItemLeft" align="right" valign="top"><a id="gab91e763e3ae44501f7c4f7b7ff8aca0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MATCH_SPACE</b> (uint16_t measured_ticks, uint16_t desired_us)</td></tr>
<tr class="separator:gab91e763e3ae44501f7c4f7b7ff8aca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d28d4dd67d6bf808c0328a92e2d863"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gab1d28d4dd67d6bf808c0328a92e2d863">getMarkExcessMicros</a> ()</td></tr>
<tr class="separator:gab1d28d4dd67d6bf808c0328a92e2d863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0f2fe0704a217c16ee497ba7b3630e"><td class="memItemLeft" align="right" valign="top"><a id="gada0f2fe0704a217c16ee497ba7b3630e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printActiveIRProtocols</b> (<a class="el" href="classPrint.html">Print</a> *aSerial)</td></tr>
<tr class="separator:gada0f2fe0704a217c16ee497ba7b3630e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81eee3a1f9153578d595c771688003e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga81eee3a1f9153578d595c771688003e8">IRrecv::IRrecv</a> ()</td></tr>
<tr class="separator:ga81eee3a1f9153578d595c771688003e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91be525437203fc803b3e664c867003d"><td class="memItemLeft" align="right" valign="top"><a id="ga91be525437203fc803b3e664c867003d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::IRrecv</b> (uint_fast8_t aReceivePin) __attribute__((deprecated(&quot;Please use the default <a class="el" href="classIRrecv.html">IRrecv</a> instance \&quot;IrReceiver\&quot; and IrReceiver.begin()</td></tr>
<tr class="separator:ga91be525437203fc803b3e664c867003d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9056445e9fe704bbeeb921183f7482ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga9056445e9fe704bbeeb921183f7482ab">IRrecv::IRrecv</a> (uint_fast8_t aReceivePin, uint_fast8_t aFeedbackLEDPin) __attribute__((deprecated(&quot;Please use the default <a class="el" href="classIRrecv.html">IRrecv</a> instance \&quot;IrReceiver\&quot; and IrReceiver.begin()</td></tr>
<tr class="separator:ga9056445e9fe704bbeeb921183f7482ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae15cd27543814209aba08637c943a14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gae15cd27543814209aba08637c943a14c">IRrecv::begin</a> (uint_fast8_t aReceivePin, bool aEnableLEDFeedback=false, uint_fast8_t aFeedbackLEDPin=USE_DEFAULT_FEEDBACK_LED_PIN)</td></tr>
<tr class="separator:gae15cd27543814209aba08637c943a14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbdf467cfd9eef58f3824f845bbef1c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gadbdf467cfd9eef58f3824f845bbef1c3">IRrecv::setReceivePin</a> (uint_fast8_t aReceivePinNumber)</td></tr>
<tr class="separator:gadbdf467cfd9eef58f3824f845bbef1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51001d826521bdd541762bfc5e8d7599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga51001d826521bdd541762bfc5e8d7599">IRrecv::registerReceiveCompleteCallback</a> (void(*aReceiveCompleteCallbackFunction)(void))</td></tr>
<tr class="separator:ga51001d826521bdd541762bfc5e8d7599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c06971f0e4e0c4131930c8903eb21dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga2c06971f0e4e0c4131930c8903eb21dc">IRrecv::start</a> ()</td></tr>
<tr class="separator:ga2c06971f0e4e0c4131930c8903eb21dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95227684dae4d0509c17e54394ef7c0"><td class="memItemLeft" align="right" valign="top"><a id="gaf95227684dae4d0509c17e54394ef7c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::restartTimer</b> ()</td></tr>
<tr class="separator:gaf95227684dae4d0509c17e54394ef7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d3e9314aea4a37b43b74a0b4f3f976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga69d3e9314aea4a37b43b74a0b4f3f976">IRrecv::enableIRIn</a> ()</td></tr>
<tr class="separator:ga69d3e9314aea4a37b43b74a0b4f3f976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a37950cfb8f052ac3b05692661bbaf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga0a37950cfb8f052ac3b05692661bbaf6">IRrecv::restartTimer</a> (uint32_t aMicrosecondsToAddToGapCounter)</td></tr>
<tr class="separator:ga0a37950cfb8f052ac3b05692661bbaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce783c588794c1ce90ca95a0a8d198e"><td class="memItemLeft" align="right" valign="top"><a id="ga6ce783c588794c1ce90ca95a0a8d198e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::restartTimerWithTicksToAdd</b> (uint16_t aTicksToAddToGapCounter)</td></tr>
<tr class="separator:ga6ce783c588794c1ce90ca95a0a8d198e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2ba4aadc8118c4d1012302f985f62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gacf2ba4aadc8118c4d1012302f985f62a">IRrecv::restartAfterSend</a> ()</td></tr>
<tr class="separator:gacf2ba4aadc8118c4d1012302f985f62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadb62786cd826cd539683c03734e46fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gaadb62786cd826cd539683c03734e46fe">IRrecv::stop</a> ()</td></tr>
<tr class="separator:gaadb62786cd826cd539683c03734e46fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033c644e835f4eff7c0254c7c9413022"><td class="memItemLeft" align="right" valign="top"><a id="ga033c644e835f4eff7c0254c7c9413022"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::stopTimer</b> ()</td></tr>
<tr class="separator:ga033c644e835f4eff7c0254c7c9413022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf828d23c733b1bde8f61e39230d9dbcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gaf828d23c733b1bde8f61e39230d9dbcd">IRrecv::disableIRIn</a> ()</td></tr>
<tr class="separator:gaf828d23c733b1bde8f61e39230d9dbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ffd22c2d4c6e93918d987a4b7c3ba5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga8ffd22c2d4c6e93918d987a4b7c3ba5b">IRrecv::end</a> ()</td></tr>
<tr class="separator:ga8ffd22c2d4c6e93918d987a4b7c3ba5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbf39fb284cc2d200158f20747c4ae3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gacfbf39fb284cc2d200158f20747c4ae3">IRrecv::isIdle</a> ()</td></tr>
<tr class="separator:gacfbf39fb284cc2d200158f20747c4ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40f1e16b1cc911e47ac3f0a9b3b1ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gaf40f1e16b1cc911e47ac3f0a9b3b1ec5">IRrecv::resume</a> ()</td></tr>
<tr class="separator:gaf40f1e16b1cc911e47ac3f0a9b3b1ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e37f666387134ed18393fd930f68db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga26e37f666387134ed18393fd930f68db">IRrecv::initDecodedIRData</a> ()</td></tr>
<tr class="separator:ga26e37f666387134ed18393fd930f68db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f466138c416bf4e1548f5399be0298"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gaa4f466138c416bf4e1548f5399be0298">IRrecv::available</a> ()</td></tr>
<tr class="separator:gaa4f466138c416bf4e1548f5399be0298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471a42c75e807e43827e319852536e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIRData.html">IRData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga471a42c75e807e43827e319852536e3c">IRrecv::read</a> ()</td></tr>
<tr class="separator:ga471a42c75e807e43827e319852536e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913af602be49b9182fb0b22e9e351b36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga913af602be49b9182fb0b22e9e351b36">IRrecv::decode</a> ()</td></tr>
<tr class="separator:ga913af602be49b9182fb0b22e9e351b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87abd13c6eb9f2e2c705bbe1deddecb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga87abd13c6eb9f2e2c705bbe1deddecb4">IRrecv::decodePulseDistanceWidthData</a> (uint_fast8_t aNumberOfBits, IRRawlenType aStartOffset, uint16_t aOneMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroMarkMicros, bool aMSBfirst)</td></tr>
<tr class="separator:ga87abd13c6eb9f2e2c705bbe1deddecb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0031bc0a8ed1127d3c1ee1adf314082"><td class="memItemLeft" align="right" valign="top"><a id="gaf0031bc0a8ed1127d3c1ee1adf314082"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::decodePulseDistanceWidthData</b> (uint_fast8_t aNumberOfBits, IRRawlenType aStartOffset, uint16_t aOneMarkMicros, uint16_t aZeroMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroSpaceMicros, bool aMSBfirst) __attribute__((deprecated(&quot;Please use decodePulseDistanceWidthData() with 6 parameters.&quot;)))</td></tr>
<tr class="separator:gaf0031bc0a8ed1127d3c1ee1adf314082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef9c4faf1f28323095b3b90f18e1f74"><td class="memItemLeft" align="right" valign="top"><a id="ga9ef9c4faf1f28323095b3b90f18e1f74"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::decodePulseDistanceWidthDataStrict</b> (uint_fast8_t aNumberOfBits, IRRawlenType aStartOffset, uint16_t aOneMarkMicros, uint16_t aZeroMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroSpaceMicros, bool aMSBfirst)</td></tr>
<tr class="separator:ga9ef9c4faf1f28323095b3b90f18e1f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d300dc2b49cdc7aa1e0570bf888e7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga97d300dc2b49cdc7aa1e0570bf888e7c">IRrecv::decodePulseDistanceWidthData</a> (<a class="el" href="structPulseDistanceWidthProtocolConstants.html">PulseDistanceWidthProtocolConstants</a> *aProtocolConstants, uint_fast8_t aNumberOfBits, IRRawlenType aStartOffset=3)</td></tr>
<tr class="separator:ga97d300dc2b49cdc7aa1e0570bf888e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd517e921cf41136c8744799797c75e2"><td class="memItemLeft" align="right" valign="top"><a id="gacd517e921cf41136c8744799797c75e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::initBiphaselevel</b> (uint_fast8_t aRCDecodeRawbuffOffset, uint16_t aBiphaseTimeUnit)</td></tr>
<tr class="separator:gacd517e921cf41136c8744799797c75e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44c88dd418acc5d8068dbacda37e8e9"><td class="memItemLeft" align="right" valign="top">uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gac44c88dd418acc5d8068dbacda37e8e9">IRrecv::getBiphaselevel</a> ()</td></tr>
<tr class="separator:gac44c88dd418acc5d8068dbacda37e8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6653a616af4dd5cde8f4abf2b1c157"><td class="memItemLeft" align="right" valign="top">uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga9d6653a616af4dd5cde8f4abf2b1c157">IRrecv::compare</a> (uint16_t oldval, uint16_t newval)</td></tr>
<tr class="separator:ga9d6653a616af4dd5cde8f4abf2b1c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33be9e29578a2eb95beb3da169228dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gab33be9e29578a2eb95beb3da169228dc">IRrecv::decodeHash</a> ()</td></tr>
<tr class="separator:gab33be9e29578a2eb95beb3da169228dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc379370caac8ca6ab6f1fd1a4cc4359"><td class="memItemLeft" align="right" valign="top"><a id="gacc379370caac8ca6ab6f1fd1a4cc4359"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::decodeHashOld</b> (<a class="el" href="structdecode__results.html">decode_results</a> *aResults)</td></tr>
<tr class="separator:gacc379370caac8ca6ab6f1fd1a4cc4359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b3bcea4b42c620264d9212e409238e"><td class="memItemLeft" align="right" valign="top"><a id="ga69b3bcea4b42c620264d9212e409238e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::checkHeader</b> (<a class="el" href="structPulseDistanceWidthProtocolConstants.html">PulseDistanceWidthProtocolConstants</a> *aProtocolConstants)</td></tr>
<tr class="separator:ga69b3bcea4b42c620264d9212e409238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00cc7b682411c68ccd2056b1d45fa84"><td class="memItemLeft" align="right" valign="top"><a id="gad00cc7b682411c68ccd2056b1d45fa84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::checkForRepeatSpaceTicksAndSetFlag</b> (uint16_t aMaximumRepeatSpaceTicks)</td></tr>
<tr class="separator:gad00cc7b682411c68ccd2056b1d45fa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6a77e0e70e85964847b9c052f137f7"><td class="memItemLeft" align="right" valign="top"><a id="ga8f6a77e0e70e85964847b9c052f137f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::checkForRecordGapsMicros</b> (<a class="el" href="classPrint.html">Print</a> *aSerial)</td></tr>
<tr class="separator:ga8f6a77e0e70e85964847b9c052f137f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga740768b87395a3bb6f54e577a99c1c1b"><td class="memItemLeft" align="right" valign="top"><a id="ga740768b87395a3bb6f54e577a99c1c1b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::printActiveIRProtocols</b> (<a class="el" href="classPrint.html">Print</a> *aSerial)</td></tr>
<tr class="separator:ga740768b87395a3bb6f54e577a99c1c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58403efdf845d0eca9e647f12b6ff061"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga58403efdf845d0eca9e647f12b6ff061">IRrecv::printIRResultShort</a> (<a class="el" href="classPrint.html">Print</a> *aSerial, bool aPrintRepeatGap=true, bool aCheckForRecordGapsMicros=true)</td></tr>
<tr class="separator:ga58403efdf845d0eca9e647f12b6ff061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4ee9436861333c2737f9272a4fadc7"><td class="memItemLeft" align="right" valign="top"><a id="ga3c4ee9436861333c2737f9272a4fadc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::printDistanceWidthTimingInfo</b> (<a class="el" href="classPrint.html">Print</a> *aSerial, <a class="el" href="structDistanceWidthTimingInfoStruct.html">DistanceWidthTimingInfoStruct</a> *aDistanceWidthTimingInfo)</td></tr>
<tr class="separator:ga3c4ee9436861333c2737f9272a4fadc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad82404b499add472db4619a3b945b4d"><td class="memItemLeft" align="right" valign="top"><a id="gaad82404b499add472db4619a3b945b4d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::getMaximumMarkTicksFromRawData</b> ()</td></tr>
<tr class="separator:gaad82404b499add472db4619a3b945b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e92727dd8e239bf8281b9f76fc5eca"><td class="memItemLeft" align="right" valign="top"><a id="ga85e92727dd8e239bf8281b9f76fc5eca"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::getMaximumSpaceTicksFromRawData</b> ()</td></tr>
<tr class="separator:ga85e92727dd8e239bf8281b9f76fc5eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a68dde740e70e436bf139798d168dc6"><td class="memItemLeft" align="right" valign="top"><a id="ga1a68dde740e70e436bf139798d168dc6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::getMaximumTicksFromRawData</b> (bool aSearchSpaceInsteadOfMark)</td></tr>
<tr class="separator:ga1a68dde740e70e436bf139798d168dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63243378b0c763d659a870b6e4f04eb"><td class="memItemLeft" align="right" valign="top"><a id="gae63243378b0c763d659a870b6e4f04eb"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::getTotalDurationOfRawData</b> ()</td></tr>
<tr class="separator:gae63243378b0c763d659a870b6e4f04eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe924ffc10b8814a5f3303b3df907dd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gabe924ffc10b8814a5f3303b3df907dd7">IRrecv::printIRSendUsage</a> (<a class="el" href="classPrint.html">Print</a> *aSerial)</td></tr>
<tr class="separator:gabe924ffc10b8814a5f3303b3df907dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4597a1f83fb256e1673291c424449c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga4597a1f83fb256e1673291c424449c51">IRrecv::printIRResultMinimal</a> (<a class="el" href="classPrint.html">Print</a> *aSerial)</td></tr>
<tr class="separator:ga4597a1f83fb256e1673291c424449c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d8405bf5ec373798c74684b9c7c2e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga0d8405bf5ec373798c74684b9c7c2e2d">IRrecv::printIRResultRawFormatted</a> (<a class="el" href="classPrint.html">Print</a> *aSerial, bool aOutputMicrosecondsInsteadOfTicks=true)</td></tr>
<tr class="separator:ga0d8405bf5ec373798c74684b9c7c2e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21364e5f35756fe0f72581c00b1b33b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga21364e5f35756fe0f72581c00b1b33b1">IRrecv::compensateAndPrintIRResultAsCArray</a> (<a class="el" href="classPrint.html">Print</a> *aSerial, bool aOutputMicrosecondsInsteadOfTicks=true)</td></tr>
<tr class="separator:ga21364e5f35756fe0f72581c00b1b33b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a515633f91a505e621cba3bab5e53d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga5a515633f91a505e621cba3bab5e53d0">IRrecv::compensateAndStoreIRResultInArray</a> (uint8_t *aArrayPtr)</td></tr>
<tr class="separator:ga5a515633f91a505e621cba3bab5e53d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24919a83cfbea5b2c53a851e1d3fed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#gae24919a83cfbea5b2c53a851e1d3fed0">IRrecv::printIRResultAsCVariables</a> (<a class="el" href="classPrint.html">Print</a> *aSerial)</td></tr>
<tr class="separator:gae24919a83cfbea5b2c53a851e1d3fed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59a9b756d71f983bf9f0a28d25f238f"><td class="memItemLeft" align="right" valign="top"><a id="gad59a9b756d71f983bf9f0a28d25f238f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::getProtocolString</b> ()</td></tr>
<tr class="separator:gad59a9b756d71f983bf9f0a28d25f238f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d69eee1eaf3d055334399b567e6f79"><td class="memItemLeft" align="right" valign="top"><a id="ga00d69eee1eaf3d055334399b567e6f79"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IRrecv::decode_old</b> (<a class="el" href="structdecode__results.html">decode_results</a> *aResults)</td></tr>
<tr class="separator:ga00d69eee1eaf3d055334399b567e6f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga40297ba8cf5a1c89fea2e9844c5e8d9e"><td class="memItemLeft" align="right" valign="top"><a id="ga40297ba8cf5a1c89fea2e9844c5e8d9e"></a>
const char string_Unknown[]&#160;</td><td class="memItemRight" valign="bottom"><b>PROGMEM</b> = &quot;UNKNOWN&quot;</td></tr>
<tr class="separator:ga40297ba8cf5a1c89fea2e9844c5e8d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6813a2b456e5359ce674699c85a61cf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIRrecv.html">IRrecv</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Receiving.html#ga6813a2b456e5359ce674699c85a61cf9">IrReceiver</a></td></tr>
<tr class="separator:ga6813a2b456e5359ce674699c85a61cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938046a49af083b7d470e61fd77e12ed"><td class="memItemLeft" align="right" valign="top"><a id="ga938046a49af083b7d470e61fd77e12ed"></a>
struct <a class="el" href="structirparams__struct.html">irparams_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><b>irparams</b></td></tr>
<tr class="separator:ga938046a49af083b7d470e61fd77e12ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f6267aa36f20f3aa1409b250aa6b67"><td class="memItemLeft" align="right" valign="top"><a id="ga99f6267aa36f20f3aa1409b250aa6b67"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>sMicrosAtLastStopTimer</b> = 0</td></tr>
<tr class="separator:ga99f6267aa36f20f3aa1409b250aa6b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aabdbfa5a0a6090e938212745b4871e"><td class="memItemLeft" align="right" valign="top"><a id="ga8aabdbfa5a0a6090e938212745b4871e"></a>
uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><b>sBiphaseDecodeRawbuffOffset</b></td></tr>
<tr class="separator:ga8aabdbfa5a0a6090e938212745b4871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33950d3b355b78a28d6f54b6af6e7b8"><td class="memItemLeft" align="right" valign="top"><a id="gac33950d3b355b78a28d6f54b6af6e7b8"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>sBiphaseCurrentTimingIntervals</b></td></tr>
<tr class="separator:gac33950d3b355b78a28d6f54b6af6e7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa340a1dbbee30ea603df9f63bb55027"><td class="memItemLeft" align="right" valign="top"><a id="gafa340a1dbbee30ea603df9f63bb55027"></a>
uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><b>sBiphaseUsedTimingIntervals</b></td></tr>
<tr class="separator:gafa340a1dbbee30ea603df9f63bb55027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae25d907bed7a0f0298f9cf105d89f86f"><td class="memItemLeft" align="right" valign="top"><a id="gae25d907bed7a0f0298f9cf105d89f86f"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>sBiphaseTimeUnit</b></td></tr>
<tr class="separator:gae25d907bed7a0f0298f9cf105d89f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bdd668aa583bfcd42fc7ecffbe55653"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>ProtocolNames</b> []</td></tr>
<tr class="separator:ga3bdd668aa583bfcd42fc7ecffbe55653"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa4f466138c416bf4e1548f5399be0298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f466138c416bf4e1548f5399be0298">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if IR receiver data is available. </p>

</div>
</div>
<a id="gae15cd27543814209aba08637c943a14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae15cd27543814209aba08637c943a14c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::begin </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>aReceivePin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aEnableLEDFeedback</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>aFeedbackLEDPin</em> = <code>USE_DEFAULT_FEEDBACK_LED_PIN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the receive and feedback pin </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aReceivePin</td><td>The Arduino pin number, where a demodulating IR receiver is connected. </td></tr>
    <tr><td class="paramname">aEnableLEDFeedback</td><td>if true / ENABLE_LED_FEEDBACK, then let the feedback led blink on receiving IR signal </td></tr>
    <tr><td class="paramname">aFeedbackLEDPin</td><td>if 0 / USE_DEFAULT_FEEDBACK_LED_PIN, then take board specific FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d6653a616af4dd5cde8f4abf2b1c157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6653a616af4dd5cde8f4abf2b1c157">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast8_t IRrecv::compare </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>oldval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>newval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two (tick) values for Hash decoder Use a tolerance of 20% to enable e.g. 500 and 600 (NEC timing) to be equal </p><dl class="section return"><dt>Returns</dt><dd>0 if newval is shorter, 1 if newval is equal, and 2 if newval is longer </dd></dl>

</div>
</div>
<a id="ga21364e5f35756fe0f72581c00b1b33b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21364e5f35756fe0f72581c00b1b33b1">&#9670;&nbsp;</a></span>compensateAndPrintIRResultAsCArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::compensateAndPrintIRResultAsCArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPrint.html">Print</a> *&#160;</td>
          <td class="paramname"><em>aSerial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aOutputMicrosecondsInsteadOfTicks</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump out the IrReceiver.decodedIRData.rawDataPtr-&gt;rawbuf[] to be used as C definition for sendRaw().</p>
<p>Compensate received values by MARK_EXCESS_MICROS, like it is done for decoding! <a class="el" href="classPrint.html">Print</a> ticks in 8 bit format to save space. Maximum is 255*50 microseconds = 12750 microseconds = 12.75 ms, which hardly ever occurs inside an IR sequence. Recording of IRremote anyway stops at a gap of RECORD_GAP_MICROS (5 ms).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSerial</td><td>The <a class="el" href="classPrint.html">Print</a> object on which to write, for Arduino you can use &amp;Serial. </td></tr>
    <tr><td class="paramname">aOutputMicrosecondsInsteadOfTicks</td><td>Output the (rawbuf_values * MICROS_PER_TICK) for better readability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a515633f91a505e621cba3bab5e53d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a515633f91a505e621cba3bab5e53d0">&#9670;&nbsp;</a></span>compensateAndStoreIRResultInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::compensateAndStoreIRResultInArray </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aArrayPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store the decodedIRData to be used for sendRaw().</p>
<p>Compensate received values by MARK_EXCESS_MICROS, like it is done for decoding and store it in an array provided.</p>
<p>Maximum for uint8_t is 255*50 microseconds = 12750 microseconds = 12.75 ms, which hardly ever occurs inside an IR sequence. Recording of IRremote anyway stops at a gap of RECORD_GAP_MICROS (5 ms). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aArrayPtr</td><td>Address of an array provided by the caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga913af602be49b9182fb0b22e9e351b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga913af602be49b9182fb0b22e9e351b36">&#9670;&nbsp;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The main decode function, attempts to decode the recently receive IR signal. The set of decoders used is determined by active definitions of the DECODE_&lt;PROTOCOL&gt; macros. Results of decoding are stored in IrReceiver.decodedIRData.* like e.g. IrReceiver.decodedIRData.command. </p><dl class="section return"><dt>Returns</dt><dd>false if no IR receiver data available, true if data available. </dd></dl>

</div>
</div>
<a id="gab33be9e29578a2eb95beb3da169228dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab33be9e29578a2eb95beb3da169228dc">&#9670;&nbsp;</a></span>decodeHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>decodeHash - decode an arbitrary IR code. Instead of decoding using a standard encoding scheme (e.g. Sony, NEC, RC5), the code is hashed to a 32-bit value.</p>
<p>The algorithm: look at the sequence of MARK and SPACE signals, and see if each one is shorter (0), the same length (1), or longer (2) than the previous MARK or SPACE. Hash the resulting sequence of 0's, 1's, and 2's to a 32-bit value. This will give a unique value for each different code (probably), for most code systems.</p>
<p>Use FNV hash algorithm: <a href="http://isthe.com/chongo/tech/comp/fnv/#FNV-param">http://isthe.com/chongo/tech/comp/fnv/#FNV-param</a> Converts the raw code values into a 32-bit hash code. Hopefully this code is unique for each button. This isn't a "real" decoding, just an arbitrary value.</p>
<p>see: <a href="http://www.righto.com/2010/01/using-arbitrary-remotes-with-arduino.html">http://www.righto.com/2010/01/using-arbitrary-remotes-with-arduino.html</a> </p>

</div>
</div>
<a id="ga97d300dc2b49cdc7aa1e0570bf888e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97d300dc2b49cdc7aa1e0570bf888e7c">&#9670;&nbsp;</a></span>decodePulseDistanceWidthData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodePulseDistanceWidthData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPulseDistanceWidthProtocolConstants.html">PulseDistanceWidthProtocolConstants</a> *&#160;</td>
          <td class="paramname"><em>aProtocolConstants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>aNumberOfBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRRawlenType&#160;</td>
          <td class="paramname"><em>aStartOffset</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode pulse distance protocols for <a class="el" href="structPulseDistanceWidthProtocolConstants.html">PulseDistanceWidthProtocolConstants</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if decoding was successful </dd></dl>

</div>
</div>
<a id="ga87abd13c6eb9f2e2c705bbe1deddecb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87abd13c6eb9f2e2c705bbe1deddecb4">&#9670;&nbsp;</a></span>decodePulseDistanceWidthData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodePulseDistanceWidthData </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>aNumberOfBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRRawlenType&#160;</td>
          <td class="paramname"><em>aStartOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aOneMarkMicros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aOneSpaceMicros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aZeroMarkMicros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aMSBfirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode pulse distance width protocols. We only check the mark or space length of a 1, otherwise we always assume a 0!</p>
<p>We can have the following protocol timings PULSE_DISTANCE: Pause/spaces have different length and determine the bit value, longer space is 1. Pulses/marks can be constant, like NEC. PULSE_WIDTH: Pulses/marks have different length and determine the bit value, longer mark is 1. Pause/spaces can be constant, like Sony. PULSE_DISTANCE_WIDTH: Pulses/marks and pause/spaces have different length, often the bit length is constant, like MagiQuest. Can be decoded by PULSE_DISTANCE decoder.</p>
<p>Input is IrReceiver.decodedIRData.rawDataPtr-&gt;rawbuf[] Output is IrReceiver.decodedIRData.decodedRawData</p>
<p>Assume PULSE_DISTANCE if aOneMarkMicros == aZeroMarkMicros</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aNumberOfBits</td><td>Number of bits to decode from decodedIRData.rawDataPtr-&gt;rawbuf[] array. </td></tr>
    <tr><td class="paramname">aStartOffset</td><td>Offset in decodedIRData.rawDataPtr-&gt;rawbuf[] to start decoding. Must point to a mark. </td></tr>
    <tr><td class="paramname">aOneMarkMicros</td><td>Checked if PULSE_WIDTH </td></tr>
    <tr><td class="paramname">aZeroMarkMicros</td><td>Required for deciding if we have PULSE_DISTANCE. </td></tr>
    <tr><td class="paramname">aOneSpaceMicros</td><td>Checked if PULSE_DISTANCE. </td></tr>
    <tr><td class="paramname">aMSBfirst</td><td>If true send Most Significant Bit first, else send Least Significant Bit (lowest bit) first. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If decoding was successful </dd></dl>

</div>
</div>
<a id="gaf828d23c733b1bde8f61e39230d9dbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf828d23c733b1bde8f61e39230d9dbcd">&#9670;&nbsp;</a></span>disableIRIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::disableIRIn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="group__Receiving.html#gaadb62786cd826cd539683c03734e46fe">stop()</a>. </p>

</div>
</div>
<a id="ga69d3e9314aea4a37b43b74a0b4f3f976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69d3e9314aea4a37b43b74a0b4f3f976">&#9670;&nbsp;</a></span>enableIRIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::enableIRIn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="group__Receiving.html#ga2c06971f0e4e0c4131930c8903eb21dc">start()</a>. </p>

</div>
</div>
<a id="ga8ffd22c2d4c6e93918d987a4b7c3ba5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ffd22c2d4c6e93918d987a4b7c3ba5b">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="group__Receiving.html#gaadb62786cd826cd539683c03734e46fe">stop()</a>. </p>

</div>
</div>
<a id="gac44c88dd418acc5d8068dbacda37e8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44c88dd418acc5d8068dbacda37e8e9">&#9670;&nbsp;</a></span>getBiphaselevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast8_t IRrecv::getBiphaselevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the level of one time interval (aBiphaseTimeUnit) at a time from the raw buffer. The RC5/6 decoding is easier if the data is broken into time intervals. E.g. if the buffer has mark for 2 time intervals and space for 1, successive calls to getBiphaselevel will return 1, 1, 0. </p><pre class="fragment">          _   _   _   _   _   _   _   _   _   _   _   _   _
    _____| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |
           ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^    Significant clock edge
          _     _   _   ___   _     ___     ___   _   - Mark
</pre><p> Data _____| |___| |_| |_| |_| |___| |___| |_| | - Data starts with a mark-&gt;space bit 1 0 0 0 1 1 0 1 0 1 1 - Space A mark to space at a significant clock edge results in a 1 A space to mark at a significant clock edge results in a 0 (for RC6) Returns current level [MARK or SPACE] or -1 for error (measured time interval is not a multiple of sBiphaseTimeUnit). </p>

</div>
</div>
<a id="gab1d28d4dd67d6bf808c0328a92e2d863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1d28d4dd67d6bf808c0328a92e2d863">&#9670;&nbsp;</a></span>getMarkExcessMicros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getMarkExcessMicros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Getter function for MARK_EXCESS_MICROS </p>

</div>
</div>
<a id="ga26e37f666387134ed18393fd930f68db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e37f666387134ed18393fd930f68db">&#9670;&nbsp;</a></span>initDecodedIRData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::initDecodedIRData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is internally called by decode before calling decoders. Must be used to setup data, if you call decoders manually. </p>

</div>
</div>
<a id="ga81eee3a1f9153578d595c771688003e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81eee3a1f9153578d595c771688003e8">&#9670;&nbsp;</a></span>IRrecv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IRrecv::IRrecv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiate the <a class="el" href="classIRrecv.html">IRrecv</a> class. Multiple instantiation is not supported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRReceivePin</td><td>Arduino pin to use. No sanity check is made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9056445e9fe704bbeeb921183f7482ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9056445e9fe704bbeeb921183f7482ab">&#9670;&nbsp;</a></span>IRrecv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IRrecv::IRrecv </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>aReceivePin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>aFeedbackLEDPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiate the <a class="el" href="classIRrecv.html">IRrecv</a> class. Multiple instantiation is not supported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aReceivePin</td><td>Arduino pin to use, where a demodulating IR receiver is connected. </td></tr>
    <tr><td class="paramname">aFeedbackLEDPin</td><td>if 0, then take board specific FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacfbf39fb284cc2d200158f20747c4ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfbf39fb284cc2d200158f20747c4ae3">&#9670;&nbsp;</a></span>isIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::isIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns status of reception </p><dl class="section return"><dt>Returns</dt><dd>true if no reception is on-going. </dd></dl>

</div>
</div>
<a id="ga4472564ea96b1ee10b51f594f60d7aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4472564ea96b1ee10b51f594f60d7aeb">&#9670;&nbsp;</a></span>matchMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matchMark </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aMeasuredTicks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aMatchValueMicros</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compensate for marks exceeded by demodulator hardware </p><dl class="section return"><dt>Returns</dt><dd>true, if values match </dd></dl>

</div>
</div>
<a id="ga7902b620f6c01463b5b6e50ef604ac8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7902b620f6c01463b5b6e50ef604ac8b">&#9670;&nbsp;</a></span>matchSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matchSpace </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aMeasuredTicks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aMatchValueMicros</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compensate for spaces shortened by demodulator hardware </p><dl class="section return"><dt>Returns</dt><dd>true, if values match </dd></dl>

</div>
</div>
<a id="ga495b7f49ff71cde1289b118fac0f0674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga495b7f49ff71cde1289b118fac0f0674">&#9670;&nbsp;</a></span>matchTicks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matchTicks </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aMeasuredTicks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aMatchValueMicros</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Match function without compensating for marks exceeded or spaces shortened by demodulator hardware </p><dl class="section return"><dt>Returns</dt><dd>true, if values match Currently not used </dd></dl>

</div>
</div>
<a id="gae24919a83cfbea5b2c53a851e1d3fed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24919a83cfbea5b2c53a851e1d3fed0">&#9670;&nbsp;</a></span>printIRResultAsCVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::printIRResultAsCVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPrint.html">Print</a> *&#160;</td>
          <td class="paramname"><em>aSerial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classPrint.html">Print</a> results as C variables to be used for sendXXX() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSerial</td><td>The <a class="el" href="classPrint.html">Print</a> object on which to write, for Arduino you can use &amp;Serial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4597a1f83fb256e1673291c424449c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4597a1f83fb256e1673291c424449c51">&#9670;&nbsp;</a></span>printIRResultMinimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::printIRResultMinimal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPrint.html">Print</a> *&#160;</td>
          <td class="paramname"><em>aSerial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to print protocol number, address, command, raw data and repeat flag of IrReceiver.decodedIRData in one short line. Does not print a Newline / does not end with println().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSerial</td><td>The <a class="el" href="classPrint.html">Print</a> object on which to write, for Arduino you can use &amp;Serial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d8405bf5ec373798c74684b9c7c2e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d8405bf5ec373798c74684b9c7c2e2d">&#9670;&nbsp;</a></span>printIRResultRawFormatted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::printIRResultRawFormatted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPrint.html">Print</a> *&#160;</td>
          <td class="paramname"><em>aSerial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aOutputMicrosecondsInsteadOfTicks</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump out the timings in IrReceiver.decodedIRData.rawDataPtr-&gt;rawbuf[] array 8 values per line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSerial</td><td>The <a class="el" href="classPrint.html">Print</a> object on which to write, for Arduino you can use &amp;Serial. </td></tr>
    <tr><td class="paramname">aOutputMicrosecondsInsteadOfTicks</td><td>Output the (rawbuf_values * MICROS_PER_TICK) for better readability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58403efdf845d0eca9e647f12b6ff061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58403efdf845d0eca9e647f12b6ff061">&#9670;&nbsp;</a></span>printIRResultShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::printIRResultShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPrint.html">Print</a> *&#160;</td>
          <td class="paramname"><em>aSerial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aPrintRepeatGap</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aCheckForRecordGapsMicros</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to print values and flags of IrReceiver.decodedIRData in one line. Ends with println().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSerial</td><td>The <a class="el" href="classPrint.html">Print</a> object on which to write, for Arduino you can use &amp;Serial. </td></tr>
    <tr><td class="paramname">aPrintRepeatGap</td><td>If true also print the gap before repeats. </td></tr>
    <tr><td class="paramname">aCheckForRecordGapsMicros</td><td>If true, call CheckForRecordGapsMicros() which may do a long printout, which in turn may block the proper detection of repeats.* </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if CheckForRecordGapsMicros() has printed a message, i.e. gap &lt; 15ms (RECORD_GAP_MICROS_WARNING_THRESHOLD). </dd></dl>

</div>
</div>
<a id="gac45e8ead5e96868e61c65cd354758d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac45e8ead5e96868e61c65cd354758d4d">&#9670;&nbsp;</a></span>printIRResultShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printIRResultShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPrint.html">Print</a> *&#160;</td>
          <td class="paramname"><em>aSerial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structIRData.html">IRData</a> *&#160;</td>
          <td class="paramname"><em>aIRDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aPrintRepeatGap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to print decoded result and flags in one line. A static function to be able to print data to send or copied received data. Ends with println().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSerial</td><td>The <a class="el" href="classPrint.html">Print</a> object on which to write, for Arduino you can use &amp;Serial. </td></tr>
    <tr><td class="paramname">aIRDataPtr</td><td>Pointer to the data to be printed. </td></tr>
    <tr><td class="paramname">aPrintRepeatGap</td><td>If true also print the gap before repeats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe924ffc10b8814a5f3303b3df907dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe924ffc10b8814a5f3303b3df907dd7">&#9670;&nbsp;</a></span>printIRSendUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::printIRSendUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPrint.html">Print</a> *&#160;</td>
          <td class="paramname"><em>aSerial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to print values and flags of IrReceiver.decodedIRData in one line. do not print for repeats except IRDATA_FLAGS_IS_PROTOCOL_WITH_DIFFERENT_REPEAT. Ends with println(). !!!Attention: The result differs on a 8 bit or 32 bit platform!!!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSerial</td><td>The <a class="el" href="classPrint.html">Print</a> object on which to write, for Arduino you can use &amp;Serial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga471a42c75e807e43827e319852536e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga471a42c75e807e43827e319852536e3c">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIRData.html">IRData</a> * IRrecv::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If IR receiver data is available, returns pointer to IrReceiver.decodedIRData, else NULL. </p>

</div>
</div>
<a id="ga51001d826521bdd541762bfc5e8d7599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51001d826521bdd541762bfc5e8d7599">&#9670;&nbsp;</a></span>registerReceiveCompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::registerReceiveCompleteCallback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>aReceiveCompleteCallbackFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the function to call if a protocol message has arrived </p>

</div>
</div>
<a id="gacf2ba4aadc8118c4d1012302f985f62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf2ba4aadc8118c4d1012302f985f62a">&#9670;&nbsp;</a></span>restartAfterSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::restartAfterSend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restarts receiver after send. Is a NOP if sending does not require a timer. </p>

</div>
</div>
<a id="ga0a37950cfb8f052ac3b05692661bbaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a37950cfb8f052ac3b05692661bbaf6">&#9670;&nbsp;</a></span>restartTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::restartTimer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMicrosecondsToAddToGapCounter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the timer and the state machine for IR reception. We assume, that timer interrupts are disabled here, otherwise it makes no sense to use this functions. Therefore we do not need to guard the change of the volatile TickCounterForISR here :-). The tick counter value is already at 100 when <a class="el" href="group__Receiving.html#ga913af602be49b9182fb0b22e9e351b36">decode()</a> gets true, because of the 5000 us minimal gap defined in RECORD_GAP_MICROS. If TickCounterForISR is not adjusted with the value of the microseconds, the timer was stopped, it can happen, that a new IR frame is recognized as a repeat, because the value of RECORD_GAP_MICROS was not reached by TickCounterForISR counter before receiving the new IR frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMicrosecondsToAddToGapCounter</td><td>To compensate for the amount of microseconds the timer was stopped / disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf40f1e16b1cc911e47ac3f0a9b3b1ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf40f1e16b1cc911e47ac3f0a9b3b1ec5">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restart the ISR (Interrupt Service Routine) state machine, to enable receiving of the next IR frame. Internal counting of gap timing is independent of StateForISR and therefore independent of call time of <a class="el" href="group__Receiving.html#gaf40f1e16b1cc911e47ac3f0a9b3b1ec5">resume()</a>. </p>

</div>
</div>
<a id="gadbdf467cfd9eef58f3824f845bbef1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbdf467cfd9eef58f3824f845bbef1c3">&#9670;&nbsp;</a></span>setReceivePin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::setReceivePin </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>aReceivePinNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets / changes the receiver pin number </p>

</div>
</div>
<a id="ga2c06971f0e4e0c4131930c8903eb21dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c06971f0e4e0c4131930c8903eb21dc">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the receiving process. This configures the timer and the state machine for IR reception and enables the receive sample timer interrupt which consumes a small amount of CPU every 50 us. </p>

</div>
</div>
<a id="gaadb62786cd826cd539683c03734e46fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadb62786cd826cd539683c03734e46fe">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the timer for IR reception. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga6813a2b456e5359ce674699c85a61cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6813a2b456e5359ce674699c85a61cf9">&#9670;&nbsp;</a></span>IrReceiver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIRrecv.html">IRrecv</a> IrReceiver</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The receiver instance </p>

</div>
</div>
<a id="ga3bdd668aa583bfcd42fc7ecffbe55653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bdd668aa583bfcd42fc7ecffbe55653">&#9670;&nbsp;</a></span>ProtocolNames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char *const ProtocolNames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= { string_Unknown, string_PulseWidth, string_PulseDistance, string_Apple, string_Denon, string_JVC, string_LG, string_LG2,</div>
<div class="line">        string_NEC, string_NEC2, string_Onkyo, string_Panasonic, string_Kaseikyo, string_Kaseikyo_Denon, string_Kaseikyo_Sharp,</div>
<div class="line">        string_Kaseikyo_JVC, string_Kaseikyo_Mitsubishi, string_RC5, string_RC6, string_RC6A, string_Samsung, string_SamsungLG, string_Samsung48,</div>
<div class="line">        string_Sharp, string_Sony</div>
<div class="line"> </div>
<div class="line">        , string_BangOlufsen, string_BoseWave, string_Lego, string_MagiQuest, string_Whynter, string_FAST</div>
<div class="line"> </div>
<div class="line">        }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
